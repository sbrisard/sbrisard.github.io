<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2015-07-09">

<title>Sébastien Brisard’s blog - Orientation correlations among rice grains, part 5: thresholding</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Sébastien Brisard’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://cv.archives-ouvertes.fr/sbrisard"> 
<span class="menu-text">About the author</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/sbrisard"> 
<span class="menu-text">GitHub</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Orientation correlations among rice grains, part 5: thresholding</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 9, 2015</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In the <a href="../20150529-Orientation_correlations_among_rice_grains-04">previous instalment</a> of this series, we used the circle Hough transform to find the boundary of the sample and define the circular ROI. Within this ROI, we now need to segment the rice grains. In other words, starting from a gray-level image (Fig.&nbsp;<a href="#fig-01" class="quarto-xref">1</a>, left), we want to produce a binary image, where all pixels that we believe belong to rice grains are white, and all background pixels are black (Fig.&nbsp;<a href="#fig-01" class="quarto-xref">1</a>, right). This is the topic of the present post, where we will use Otsu’s automated threshold selection. I will first discuss Otsu’s method, and propose what I believe is a new interpretation of this rather old technique. Then, I will apply this method to the 3D image of rice grains, using <a href="http://scikit-image.org/">scikit-image</a>.</p>
<div id="fig-01" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="files/rice-bin_4x4x4-initial_vs_thresholded-099.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The original (left) and thresholded (right) images.
</figcaption>
</figure>
</div>
<section id="plotting-the-images-histogram" class="level1">
<h1>Plotting the image’s histogram</h1>
<p>Before we dig into Otsu’s method, we will first draw the histogram of the original image shown in Fig.&nbsp;<a href="#fig-01" class="quarto-xref">1</a> (left), remembering that the boundary was found in the <a href="../20150529-Orientation_correlations_among_rice_grains-04">previous instalment</a> to be a circle centered at <code>(219, 217)</code>, with radius <code>208</code>. The following Python code computes and saves the histogram as a SVG file, which is displayed in Fig.&nbsp;<a href="#fig-02" class="quarto-xref">2</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os.path</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.draw <span class="im">import</span> circle</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.io <span class="im">import</span> imread</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> <span class="st">"."</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> imread(os.path.join(root, <span class="st">"rice-bin_4x4x4-099.tif"</span>))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>rows, cols <span class="op">=</span> circle(<span class="dv">219</span>, <span class="dv">217</span>, <span class="dv">208</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>mpl.style.use(os.path.join(root, <span class="st">"sb-blog.mplstyle"</span>))</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> mpl.figure.Figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>h, bins, patches <span class="op">=</span> ax.hist(img[rows, cols], bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">256</span>),</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                           histtype<span class="op">=</span><span class="st">'stepfilled'</span>,</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                           color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Gray value'</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Pixel count'</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">250</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(<span class="dv">5</span>))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>fig.savefig(os.path.join(root, <span class="st">'rice-bin_4x4x4-hist-099.svg'</span>),</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            transparent<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-02" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="files/rice-bin_4x4x4-hist-099.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Histogram of the original image shown in Fig.&nbsp;<a href="#fig-01" class="quarto-xref">1</a> (left).
</figcaption>
</figure>
</div>
<p>It is observed that this histogram is relatively well suited to thresholding. Indeed, it exhibits two peaks which are fairly well-separated, and the pixel counts between these peaks are rather small. However, these pixel counts never go to zero, which means that no matter the threshold, the thresholded image will always be wrong!</p>
</section>
<section id="otsus-method" class="level1">
<h1>Otsu’s method</h1>
<p>Otsu’s method (<a href="https://doi.org/10.1109/TSMC.1979.4310076">Otsu, 1979</a>) is a popular thresholding technique. It is quite effective on simple images, when the histogram has two well separated peaks. Otsu's optimum threshold is often presented as (quoted from <a href="https://en.wikipedia.org/wiki/Otsu%27s_method">Wikipedia</a>)</p>
<blockquote class="blockquote">
<p>separating the two classes so that their combined spread (intra-class variance) is minimal, or equivalently (because the sum of pairwise squared distances is constant), so that their inter-class variance is maximal.</p>
</blockquote>
<p>I have always found this definition non-intuitive. Why should maximizing the intra-class variance return a satisfactorily thresholded image? Well, I came to develop my own understanding of Otsu’s method.</p>
<p>We start with the original (noisy) image, which will be considered as a map <span class="math inline">\(f\colon E\to\{0,\ldots,L-1\}\)</span> from the set <span class="math inline">\(E\)</span> of pixels to the set <span class="math inline">\(\{0,\ldots,L-1\}\)</span> of gray levels (<span class="math inline">\(L\)</span> denotes the total number of gray levels). It should be noted that in Otsu’s original paper (<a href="https://doi.org/10.1109/TSMC.1979.4310076">1979</a>), the gray levels span <span class="math inline">\(\{1,\ldots,L\}\)</span> rather than <span class="math inline">\(\{0,\ldots,L-1\}\)</span>: the convention adopted here is more in line with standard images.</p>
<p>We want to find the “best” binary approximation of <span class="math inline">\(f\)</span>, in the sense of Problem&nbsp;1 defined below.</p>
<div id="exr-01" class="theorem exercise">
<p><span class="theorem-title"><strong>Problem 1</strong></span> Find two gray levels <span class="math inline">\(g_0\)</span> and <span class="math inline">\(g_1\)</span>, and the map <span class="math inline">\(g\colon E\to\{g_0, g_1\}\)</span> that minimizes the distance</p>
<p><span class="math display">\[d(f, g)^2=\sum_{x\in E}\left[f(x)-g(x)\right]^{2}.\]</span></p>
</div>
<p>At this point, it should be noted that the above choice of distance will result in <span class="math inline">\(g\)</span> being the maximum likelihood estimator of <span class="math inline">\(f\)</span> in the presence of Gaussian noise (a common assumption in image analysis –&nbsp;even if noise rather follows a Poisson distribution on real detectors). It can readily be verified that <a href="#exr-01" class="quarto-xref">Problem&nbsp;1</a> in fact reduces to Otsu’s method! To prove this assertion, we need to rewrite this problem. Let <span class="math inline">\(g\)</span> denote its solution. Then, for all <span class="math inline">\(x, y\in E\)</span> <span id="eq-01"><span class="math display">\[
f(x) = f(y)\quad\Rightarrow\quad g(x)=g(y),
\tag{1}\]</span></span> <span id="eq-02"><span class="math display">\[
f(x) &lt; f(y)\quad\Rightarrow\quad g(x) \leq g(y).
\tag{2}\]</span></span></p>
<p>The proof of the above assertions can be found in the appendices at the end of this post. Assertion&nbsp;(<a href="#eq-01" class="quarto-xref">1</a>) proves that <span class="math inline">\(g(x)\)</span> depends on the gray value of <span class="math inline">\(x\)</span> in image <span class="math inline">\(f\)</span>, not on the pixel <span class="math inline">\(x\)</span> itself. Therefore, <a href="#exr-01">Problem&nbsp;1</a> leads to a histogram based segmentation method. Assuming <span class="math inline">\(g_0 &lt; g_1\)</span>, we then define <span class="math inline">\(k\)</span> as follows <span id="eq-03"><span class="math display">\[
k=\max\{f(x), x\in E,g(x)=g_0\},
\tag{3}\]</span></span> and obviously <span id="eq-04"><span class="math display">\[
g(x)=g_0\quad\Rightarrow\quad f(x)\leq k.
\tag{4}\]</span></span></p>
<p>Conversely, from assertions&nbsp;(<a href="#eq-01" class="quarto-xref">1</a>) and (<a href="#eq-02" class="quarto-xref">2</a>), <span id="eq-05"><span class="math display">\[
g(x)=g_1\quad\Rightarrow\quad f(x) &gt; k.
\tag{5}\]</span></span></p>
<p>As a conclusion, the optimum function <span class="math inline">\(g\)</span> is defined as follows from <span class="math inline">\(k\)</span>, <span class="math inline">\(g_0\)</span> and <span class="math inline">\(g_1\)</span> <span id="eq-06"><span class="math display">\[
g(x)=\begin{cases}
g_0 &amp; \text{if }f(x)\leq k,\\
g_1 &amp; \text{if }f(x) &gt; k,
\end{cases}
\tag{6}\]</span></span> and <span class="math inline">\(k\)</span> appears as a threshold. Therefore, <a href="#exr-01" class="quarto-xref">Problem&nbsp;1</a> effectively reduces to a thresholding problem, and an equivalent formulation is given below.</p>
<div id="exr-02" class="theorem exercise">
<p><span class="theorem-title"><strong>Problem 2</strong></span> Find the threshold <span class="math inline">\(k\)</span> and two gray levels <span class="math inline">\(g_0\)</span> and <span class="math inline">\(g_1\)</span> that minimize <span id="eq-07"><span class="math display">\[
J_3(k, g_0, g_1)=\sum_{\alpha=0,1}\sum_{x\in C_\alpha(k)}\left[f(x)-g_\alpha)\right]^{2},
\tag{7}\]</span></span> where <span id="eq-08"><span class="math display">\[
C_0(k)=\{x\in E, f(x) &lt; k\},
\tag{8}\]</span></span> and <span id="eq-09"><span class="math display">\[
C_1(k)=\{x\in E, f(x) \geq k\}.
\tag{9}\]</span></span></p>
</div>
<p>The solution to <a href="#exr-01" class="quarto-xref">Problem&nbsp;1</a> is retrieved from the solution to <a href="#exr-02" class="quarto-xref">Problem&nbsp;2</a> by means of Eq.&nbsp;(<a href="#eq-06" class="quarto-xref">6</a>). It should be noted that optimization of <span class="math inline">\(J_3\)</span> with respect to <span class="math inline">\(g_0\)</span> and <span class="math inline">\(g_1\)</span> is trivial, and we find that <span class="math inline">\(g_\alpha=\mu_\alpha(k)\)</span>, where <span class="math inline">\(\mu_\alpha(k)\)</span> is the average gray level in class <span class="math inline">\(C_\alpha(k)\)</span> <span id="eq-10"><span class="math display">\[
\mu_\alpha(k)=\frac1{N_\alpha(k)}\sum_{x\in C_\alpha(k)}f(x),
\tag{10}\]</span></span> where <span class="math inline">\(N_\alpha(k)\)</span> is the number of pixels in class <span class="math inline">\(C_\alpha(k)\)</span>. We are therefore left with the following minimization problem.</p>
<div id="exr-03" class="theorem exercise">
<p><span class="theorem-title"><strong>Problem 3</strong></span> Find <span class="math inline">\(k\)</span> that minimizes <span id="eq-11"><span class="math display">\[
J(k)=\sum_{\alpha=0,1}\sum_{x\in C_\alpha(k)}\bigl[f(x)-\mu_\alpha(k)\bigr]^{2}.
\tag{11}\]</span></span></p>
</div>
<p>To prove that the minimizer of <span class="math inline">\(J\)</span> is exactly Otsu’s threshold, we first expand Eq.&nbsp;(<a href="#eq-11" class="quarto-xref">11</a>) (omitting the dependency of <span class="math inline">\(C_\alpha\)</span> and <span class="math inline">\(N_\alpha\)</span> with respect to <span class="math inline">\(k\)</span>) <span id="eq-12"><span class="math display">\[
J(k)=\sum_{x\in E}f(x)^2-\bigl(N_0\mu_0^2+N_1\mu_1^2\bigr).
\tag{12}\]</span></span></p>
<p>Introducing the total number of pixels <span class="math inline">\(N=N_0+N_1\)</span>, we have <span id="eq-13"><span class="math display">\[
\begin{aligned}[b]
N_0\mu_0^2+N_1\mu_1^2
&amp;=\frac 1N\bigl(N_0^2\mu_0^2+N_1^2\mu_1^2+N_0N_1\bigl(\mu_0^2+\mu_1^2\bigr)\bigr)\\
&amp;=\frac1N\bigl[\bigl(N_0\mu_0+N_1\mu_1\bigr)^2+N_0N_1\bigl(\mu_0-\mu_1\bigr)^2\bigr].
\end{aligned}
\tag{13}\]</span></span></p>
<p>From Eq.&nbsp;(<a href="#eq-10" class="quarto-xref">10</a>), we have <span id="eq-14"><span class="math display">\[
N_0\mu_0+N_1\mu_1=\sum_\alpha\sum_{x\in C_\alpha}f(x)=N\mu,
\tag{14}\]</span></span> where <span class="math inline">\(\mu\)</span> is the total average gray value. Gathering Eqs.&nbsp;(<a href="#eq-12" class="quarto-xref">12</a>), (<a href="#eq-13" class="quarto-xref">13</a>) and (<a href="#eq-14" class="quarto-xref">14</a>) and introducing <span class="math inline">\(\omega_\alpha=N_\alpha/N\)</span> (<span class="math inline">\(\alpha=0, 1\)</span>) we finally find <span id="eq-15"><span class="math display">\[
\begin{aligned}
J(k)
&amp;=\sum_{x\in E}f(x)^2-N\mu^2-\frac{N_0N_1}N\bigl(\mu_0-\mu_1\bigr)^2\\
&amp;=\sum_{x\in E}\bigl[f(x)-\mu\bigr]^2-N\omega_0\omega_1\bigl(\mu_0-\mu_1\bigr)^2.
\end{aligned}
\tag{15}\]</span></span></p>
<p>In the above expression, the sum over all pixels of the image is constant. Therefore, minimizing <span class="math inline">\(J\)</span> is equivalent to maximizing <span id="eq-16"><span class="math display">\[
\omega_0\omega_1\bigl(\mu_0-\mu_1\bigr)^2.
\tag{16}\]</span></span></p>
<p>This is exactly how Otsu’s threshold is defined! [see <a href="https://doi.org/10.1109/TSMC.1979.4310076">Otsu, 1979</a>, Eq.&nbsp;(14)] To sum up, we started with <a href="#exr-01" class="quarto-xref">Problem&nbsp;1</a>: find the best binary approximation of a specified image. We showed that the best binary approximation was to be found amongst the class of thresholded images (see <a href="#exr-02" class="quarto-xref">Problem&nbsp;2</a> and <a href="#exr-03" class="quarto-xref">Problem&nbsp;3</a>). Then, the optimum threshold was found to coincide with Otsu’s. In that sense, Otsu’s method is equivalent to <a href="#exr-01" class="quarto-xref">Problem&nbsp;1</a>.</p>
<p>It is interesting to realize that there is a connection between Otsu’s method and the Mumford–Shah functional (<a href="https://doi.org/10.1002/cpa.3160420503">Mumford and Shah, 1989</a>). Indeed, Mumford and Shah also seek the best binary (or more generally, <span class="math inline">\(n\)</span>-component) approximation of an image in the <span class="math inline">\(L^2\)</span> sense. However, their cost function also penalizes the total variation as well as the total length of the interfaces. As such, segmentation techniques based on the Mumford–Shah functional are not histogram-based.</p>
</section>
<section id="thresholding-the-whole-stack-of-images" class="level1">
<h1>Thresholding the whole stack of images</h1>
<p>In the present section, we will first compute the threshold based on the histogram of the whole stack. <a href="http://scikit-image.org/">skimage</a> does implement <a href="http://scikit-image.org/docs/dev/api/skimage.filters.html#threshold-otsu">threshold_otsu</a>, and we will make use of this function. Attention must be paid to the fact that for each slice, the analysis must be restricted to a circular ROI.</p>
<p>We first load all binned slices, and recover the parameters of the circular boundaries of each ROI, from the <a href="../20150529-Orientation_correlations_among_rice_grains-04">previous instalment</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os.path</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.draw <span class="im">import</span> circle</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.filters <span class="im">import</span> threshold_otsu</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.io <span class="im">import</span> imread, imsave</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.util <span class="im">import</span> img_as_ubyte</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>previous_post <span class="op">=</span> <span class="st">'20150529-Orientation_correlations_among_rice_grains-04'</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>circle_params <span class="op">=</span> np.load(os.path.join(<span class="st">'..'</span>, previous_post,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">'circle_params.npy'</span>))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>num_slices <span class="op">=</span> circle_params.shape[<span class="dv">0</span>]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> <span class="st">"/media/sf_sbrisard/Documents/tmp"</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>name <span class="op">=</span> os.path.join(root, <span class="st">'bin_4x4x4'</span>, <span class="st">'rice-bin_4x4x4-</span><span class="sc">{0:03d}</span><span class="st">.tif'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>images <span class="op">=</span> [imread(name.<span class="bu">format</span>(i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_slices)]</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Loaded </span><span class="sc">{}</span><span class="st"> images.'</span>.<span class="bu">format</span>(<span class="bu">len</span>(images)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Loaded 172 images.</code></pre>
<p>We then concatenate in <code>pixel_values</code> the gray levels of all pixels located inside the relevant ROI.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>pixel_values <span class="op">=</span> []</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> img, params <span class="kw">in</span> <span class="bu">zip</span>(images, circle_params):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> circle(<span class="op">*</span>params)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    pixel_values.append(img[rows, cols].ravel())</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>pixel_values <span class="op">=</span> np.concatenate(pixel_values)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Concatenated </span><span class="sc">{}</span><span class="st"> pixel values.'</span>.<span class="bu">format</span>(pixel_values.shape[<span class="dv">0</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Concatenated 23342700 pixel values.</code></pre>
<p>This concatenated array is then passed to <code>threshold_otsu</code> to compute the threshold.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> threshold_otsu(pixel_values)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Otsu's threshold = </span><span class="sc">{}</span><span class="st">."</span>.<span class="bu">format</span>(threshold))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Otsu's threshold = 126.</code></pre>
<p>Finally, the images are thresholded and saved</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>basename <span class="op">=</span> <span class="st">'rice-bin_4x4x4-otsu_</span><span class="sc">{0}</span><span class="st">-</span><span class="sc">{1:03d}</span><span class="st">.tif'</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>names <span class="op">=</span> [os.path.join(root, <span class="st">'bin_4x4x4-otsu'</span>, basename.<span class="bu">format</span>(threshold, i))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>         <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_slices)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> img, params, name <span class="kw">in</span> <span class="bu">zip</span>(images, circle_params, names):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> circle(<span class="op">*</span>params)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> np.zeros_like(img, dtype<span class="op">=</span>np.<span class="bu">bool</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    mask[rows, cols] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    binary <span class="op">=</span> np.logical_and(img <span class="op">&gt;</span> threshold, mask)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    imsave(name, img_as_ubyte(binary))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The above script produces a series of binary images called <code>rice-bin_4x4x4-otsu_XXX-YYY.tif</code>, where <code>XXX</code> denotes the threshold, and <code>YYY</code> is the slice number. An example of such thresholded image is given in Fig.&nbsp;<a href="#fig-01" class="quarto-xref">1</a> (right).</p>
</section>
<section id="closing-words" class="level1">
<h1>Closing words</h1>
<p>In this post, we have used Otsu’s method to threshold the 3D image of the rice grains. This is only the first step towards segmentation of this image, though, as we would like to label all rice grains. This will be the topic of the <a href="../20150930-Orientation_correlations_among_rice_grains-06">next post</a>.</p>
<p>In the present post, I also presented an alternative derivation of Otsu’s method. I believe this derivation is original, but I might be wrong. So please, do leave a comment to let me know what you think about this presentation.</p>
</section>
<section id="appendix" class="level1">
<h1>Appendix</h1>
<section id="sec-01" class="level2">
<h2 class="anchored" data-anchor-id="sec-01">Proof of assertion&nbsp;(<a href="#eq-01" class="quarto-xref">1</a>)</h2>
<p>This assertion is proved by contradiction. Let us assume that there exists two pixels <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> (<span class="math inline">\(x\neq y\)</span>) with same value in the original image [<span class="math inline">\(f(x)=f(y)\)</span>] and different values in the binary approximation [<span class="math inline">\(g(x)\neq
g(y)\)</span>]. We select <span class="math inline">\(g_2\in\{g(x),g(y)\}=\{g_0, g_1\}\)</span> so that <span class="math display">\[
\begin{aligned}
\bigl(f(x)-g_2\bigr)^2
&amp;=\bigl(f(y)-g_2\bigr)^2\\
&amp;=\min\bigl(\bigl[f(x)-g(x)\bigr]^2, \bigl[f(y)-g(y)\bigr]^2\bigr),
\end{aligned}
\]</span> and <span id="eq-17"><span class="math display">\[
\bigl[f(x)-g_2\bigr]^2+\bigl[f(y)-g_2\bigr]^2&lt;\bigl[f(x)-g(x)\bigr]^2+\bigl[f(y)-g(y)\bigr]^2,
\tag{17}\]</span></span> since <span class="math inline">\(g(x)\neq g(y)\)</span>. It should be noted that the above inequality is <em>strict</em>. We then define <span class="math inline">\(\tilde g\colon E\to\{g_0,g_1\}\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(\tilde g(x)=g_2\)</span>,</li>
<li><span class="math inline">\(\tilde g(y)=g_2\)</span>,</li>
<li><span class="math inline">\(\tilde g(z)=g(z)\)</span> if <span class="math inline">\(z\neq x\)</span> and <span class="math inline">\(z\neq y\)</span>.</li>
</ul>
<p>Then, simple algebra leads to <span class="math display">\[
d(f,\tilde g)^2-d(f,g)^2=\bigl[f(x)-g_2\bigr]^2+\bigl[f(y)-g_2\bigr]^2-\bigl[f(x)-g(x)\bigr]^2-\bigl[f(y)-g(y)\bigr]^2.
\]</span></p>
<p>From Eq.&nbsp;(<a href="#eq-17" class="quarto-xref">17</a>), we then find <span class="math inline">\(d(f,\tilde g)^2 &lt; d(f,g)^2\)</span>, which leads to a contradiction, since <span class="math inline">\(g\)</span> optimizes the distance to <span class="math inline">\(f\)</span>. Thus, assertion&nbsp;(<a href="#eq-01" class="quarto-xref">1</a>) is proved.</p>
</section>
<section id="sec-02" class="level2">
<h2 class="anchored" data-anchor-id="sec-02">Proof of assertion&nbsp;(<a href="#eq-02" class="quarto-xref">2</a>)</h2>
<p>This assertion is again proved by contradiction. Let us assume that there exists <span class="math inline">\(x, y\in E\)</span> such that <span class="math inline">\(f(x) &lt; f(y)\)</span> and <span class="math inline">\(g(x) &gt; g(y)\)</span>. Then, simple algebra shows that <span class="math display">\[
\begin{multline}
\bigl[f(x)-g(y)\bigr]^2+\bigl[f(y)-g(x)\bigr]^2=\bigl[f(x)-g(x)\bigr]^2+\bigl[f(y)-g(y)\bigr]^2\\
+2\bigl[f(y)-f(x)\bigr]\bigl[g(y)-g(x)\bigr],
\end{multline}
\]</span> and the last term is negative. Proceeding as above, we then build <span class="math inline">\(\tilde g\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(\tilde{g}(x)=g(y)\)</span>,</li>
<li><span class="math inline">\(\tilde{g}(y)=g(x)\)</span>,</li>
<li><span class="math inline">\(\tilde{g}(z)=g(z)\)</span> if <span class="math inline">\(z\neq x\)</span> and <span class="math inline">\(z\neq y\)</span>.</li>
</ul>
<p>Then <span class="math display">\[
d(f, \tilde g)^2-d(f,g)^2=\bigl[f(x)-g(y)\bigr]^2+\bigl[f(y)-g(x)\bigr]^2
-\bigl[f(x)-g(x)\bigr]^2-\bigl[f(y)-g(y)\bigr]^2,
\]</span> which is negative. Contradiction!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Except where otherwise noted, content on this blog by Sébastien Brisard is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></p>
</div>
    <div class="nav-footer-right">
<p>📧​ sebastien [dot] brisard [at] univ [dash] amu [dot] fr</p>
</div>
  </div>
</footer>




</body></html>