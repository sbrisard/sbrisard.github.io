<!DOCTYPE html>
<html lang="en">
  <head>
      <title>Sébastien Brisard's blog - Orientation correlations among rice grains, part 8: estimating the correlations</title>
    <link rel="stylesheet" href="https://sbrisard.github.io/theme/css/main.css" />
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://sbrisard.github.io/theme/katex/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"/>
    <script defer src="https://sbrisard.github.io/theme/katex/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://sbrisard.github.io/theme/katex/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body, {macros: {'\\D': '\\mathrm{d}', '\\dbldot': '\\mathbin{\\mathord{:}}', '\\sym': '\\operatorname{\\mathbf{sym}}', '\\tgrad': '\\operatorname{\\mathbf{grad}}', '\\tens': '\\bm', '\\tr': '\\operatorname{tr}', '\\vec': '\\bm'}, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
    <link href="https://sbrisard.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="Sébastien Brisard's blog Full RSS Feed" />





  </head>

  <body id="index" class="home">
    <header id="siteheader">
      <img id="sitebanner" src="https://sbrisard.github.io/theme/images/banner.jpg"/>
      <div id="sitename"><a href="https://sbrisard.github.io/">Sébastien Brisard's blog <strong></strong></a></div>
      <nav id="sitemenu">
	<ul>
          <li><a href="/pages/about.html" title="About this blog">About this blog</a></li>
          <li><a href="https://cv.archives-ouvertes.fr/sbrisard" title="About me">About me</a></li>
          <li><a href="/archives.html" title="Archives">Archives</a></li>
          <li><a href="https://github.com/sbrisard" title="GitHub">GitHub</a></li>
          <li><a href="https://twitter.com/SebBrisard" title="Twitter">Twitter</a></li>
          <li><a href="feed.xml" title="RSS">RSS</a></li>
	</ul>
      </nav>
    </header>
<section id="content" class="body">
  <header>
    <h1 class="entry-title">
      <a href="https://sbrisard.github.io/posts/20160627-orientation_correlations_among_rice_grains-08.html" rel="bookmark"
         title="Permalink to Orientation correlations among rice grains, part 8: estimating the correlations">Orientation correlations among rice grains, part 8: estimating the correlations</a></h1>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2016-06-27T00:00:00+02:00">
      Published 27 June 2016
    </time>
    <address class="vcard author">
      by           <a class="url fn" href="https://sbrisard.github.io/author/sebastien-brisard.html">Sébastien Brisard</a>
    </address>
    <div class="category">
        Category: <a href="https://sbrisard.github.io/category/image-analysis.html">Image analysis</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>In the <a href="https://sbrisard.github.io/posts/20160219-orientation_correlations_among_rice_grains-07.html">previous
instalment</a>
of this series, we have analyzed the morphology of the rice grains. In
particular, we have defined their <em>orientation</em> as that of the major axis of
inertia. We are now in a position to quantify the statistics of the
orientations. We will first discuss <a href="#S1">one-point statistics</a> (each grain is
considered individually), then <a href="#S2">two-point statistics</a> (mutual orientations
of pairs of grains are considered). Finally, we will try to quantify how <a href="#Boundary_effects">the
wall of the sample container</a> influences the orientation of
the rice grains.</p>
<p><a name="S1"></a></p>
<h2>One-point order parameter</h2>
<p>Various order parameters have been introduced in order to identify preferred
orientations in assemblies of anisotropic particles. In the present post, we
will use the so-called nematic order parameter, which is used to monitor
isotropic-nematic phase transitions (<a href="https://doi.org/10.1080/00268978400101951">Eppenga and Frenkel,
1984</a>)</p>
<p><a name="eq01"></a>
$$S_1=\mathbb E\Bigl(\frac{3\cos^2\theta-1}2\Bigr)=\frac1N\sum_{i=1}^N\frac{3\cos^2\theta_i-1}2,\tag{1}$$</p>
<p>where $\mathbb E$ denotes the ensemble average, and $\theta$ is the angle of the
current particle with respect to a fixed direction. In the last equality, the
ensemble average was replaced with an empirical average over all particles in
the system.</p>
<p>If the distribution of particles is isotropic, then the pdf of the orientations
reads (in <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical
coordinates</a>, physics
convention)</p>
<p>$$p(\theta, \varphi)=\frac1{4\pi}\sin\theta\,{\mathrm d}\theta\,{\mathrm d}\varphi,$$</p>
<p>($\theta$: polar angle; $\varphi$: azimuthal angle), and we find</p>
<p>$$S_1=\frac1{4\pi}\int_{0\leq\theta\leq\pi}\int_{0\leq\varphi\leq2\pi}\frac{3\cos^2\theta-1}2\sin\theta\,{\mathrm d}\theta\,{\mathrm d}\varphi=0.$$</p>
<p>Conversely, for particles with fixed orientation, $\theta=0$ for all particles
and $S_1=1$.</p>
<p>Let us compute $S_1$ for the assembly of rice grains. In the <a href="https://sbrisard.github.io/posts/20160219-orientation_correlations_among_rice_grains-07.html">previous
instalment</a>
of this series, we have computed the orientation (unit vector) of each grain. We
first retrieve this data.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="kn">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.figure</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>

<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;/media/sf_sbrisard/Documents/tmp/rice-bin_4x4x4.hdf5&#39;</span>

<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;center_of_mass&#39;</span><span class="p">])</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;orientation&#39;</span><span class="p">])</span>
</pre></div>


<p>Now, <code>center[i, :]</code> denotes the coordinates of the center of grain <code>i</code>, while
<code>orientation[i, :]</code> denotes the orientation of grain <code>i</code>. In what follows, we
will compute $S_1$, taking the vertical as reference direction. At this point,
it should be recalled that the $z$ coordinate (along the vertical) is the first
index in the 3D image (slice number).  Therefore, $\cos\theta_i$ is given by
<code>orientation[i, 0]</code> in this context.</p>
<div class="highlight"><pre><span></span><span class="n">cos_theta</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">p2_cos_theta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">cos_theta</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;S1 = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p2_cos_theta</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>


<div class="highlight"><pre><span></span>S1 = -0.09376398099836955
</pre></div>


<p>It is observed that $S_1$ is non-zero, which indicates a slight
anisotropy. $S_1$ is a one-point descriptor of the microsctructure. In other
words, only one particle is considered at a time (orientational correlations are
not accounted for). In the next section, we will show how such correlations can
be quantified.</p>
<p><a name="S2"></a></p>
<h2>Two-point order parameter</h2>
<p>The initial motivation of this series was the quantification of orientation
correlation between anisotropic particles. The basic idea is this: anisotropic,
hard particles tend to be locally well ordered (in terms of orientation). In
other words, the closer the particles, the higher the probability that they are
(nearly) parallel. This is definitely true of flat particles (platelets), but it
is less obvious for elongated particles.</p>
<p>To measure orientation correlations between particles, Frenkel and Mulder
(<a href="https://doi.org/10.1080/00268978500101971">2002</a>) introduce $S_2(r)$, which is
defined from the above order parameter as follows. A “central particle”, $i$, is
first selected. The reference direction is the orientation $\vec n_i$ of this
central particle. Then, $S_2(r)$ is computed from Eq. <a href="#eq01">(1)</a>, for all
particles $j$ located at a distance $r$ from the central particle $i$. In this
context, we have $\cos\theta_j=\vec n_i\cdot\vec n_j$. The empirical estimation
of this two-point order parameter therefore reads</p>
<p><a name="eq02"></a>
$$S_2(r)=\frac1N\sum_{i=1}^N\frac1{\operatorname{\#}\mathcal C_i(r, r+\Delta r)}\sum_{j\in\mathcal C_i(r, r+\Delta r)}\frac{3\bigl(\vec n_i\cdot\vec n_j\bigr)^2-1}2,\tag{2}$$</p>
<p>where $\vec n_j$ denotes the orientation of particle $j$. $\mathcal C_i(r_1,
r_2)$ is the set of particles centered at a distance $r$ from particle $i$, with
$r_1\leq r\leq r_2$</p>
<p>$$\mathcal C_i(r_1, r_2)=\bigl\{j, 1\leq j\leq N, r_1\leq\lVert\vec x_j-\vec x_i\rVert\leq r_2\bigr\}$$</p>
<p>($\vec x_i$: center of particle $i$). Eq. <a href="#eq02">(2)</a> is readily implemented in
Python (using <code>numpy</code> and <code>scipy</code>). We first compute the distance matrix, and
round it to the nearest integer, which then defines <code>labels[i, j]</code> (to be passed
to <code>scipy.ndimage.mean</code>).</p>
<div class="highlight"><pre><span></span><span class="n">distance</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</pre></div>


<p>We then compute, for each pair <code>(i, j)</code>, the cosine <code>cos_theta[i, j]</code> of the
angle between particles <code>i</code> and <code>j</code>. We also evaluate the second Legendre
polynomial $P_2$ for each value of $\cos\theta$</p>
<p>$$P_2(x)=(3x^2-1)/2.$$</p>
<div class="highlight"><pre><span></span><span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">orientation</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">orientation</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">p2_cos_theta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">cos_theta</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>


<p>Now comes the tricky part: the double sum over <em>all</em> grains $i$, and only grains
$j$ belonging to $\mathcal C_i(r, r+\Delta r)$ (where $\Delta
r=1\,\text{pix}$). For $i$ fixed, the inner sum</p>
<p>$$\frac1{\operatorname{\#}\mathcal C_i(r, r+1)}\sum_{j\in\mathcal C_i(r, r+1)}\frac{3\bigl(\vec n_i\cdot\vec n_j\bigr)^2-1}2,$$</p>
<p>can be seen as the mean of all cells <code>p2_cos_theta[i, j]</code> for which <code>labels[i,
j]==r</code>. As such, it can be computed with the
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.mean.html#scipy-ndimage-mean">scipy.ndimage.mean</a>
function (similar in spirit to the
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sum.html#scipy.ndimage.sum">scipy.ndimage.sum</a>
function that was used in the <a href="https://sbrisard.github.io/posts/20160219-orientation_correlations_among_rice_grains-07.html">previous
instalment</a>
of this series). In the following snippet, we apply this function to each row of
<code>p2_cos_theta</code> in turn (I could not find a way to get rid of this loop!).</p>
<div class="highlight"><pre><span></span><span class="n">num_grains</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="n">inner_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_grains</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_grains</span><span class="p">):</span>
    <span class="n">inner_sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">p2_cos_theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/usr/lib/python3/dist-packages/scipy/ndimage/measurements.py:639: RuntimeWarning: invalid value encountered in true_divide
  return sum / numpy.asanyarray(count).astype(numpy.float)
</pre></div>


<p>Then, the outer sum in Eq. <a href="#eq02">(2)</a> is a simple mean (ignoring NaNs).</p>
<div class="highlight"><pre><span></span><span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">inner_sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>The resulting correlation function is plotted on <a href="#fig01">Fig. 1</a>.</p>
<div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$r\;[\mathrm{pix}]$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$S_2(r)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;S2.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/usr/lib/python3/dist-packages/matplotlib/tight_layout.py:231: UserWarning: tight_layout : falling back to Agg renderer
  warnings.warn(&quot;tight_layout : falling back to Agg renderer&quot;)
</pre></div>


<p><a name="fig01"></a>
<img alt="Plot of S2" class="figure" src="https://sbrisard.github.io/posts/20160627-Orientation_correlations_among_rice_grains-08/S2.png"></p>
<figcaption>Figure&nbsp;1:&nbsp;The orientational correlation function $S_2(r)$.</figcaption>

<p>For small values of $r$, the curve is not relevant, since very little grains are
close enough (remember that rice grains are non-overlapping
particles!). Similarly, the increase at large values of the center-to-center
distance $r$ should be considered with caution. Indeed, due to the limited size
of the specimen, sampling is insufficient at high $r$. For intermediate values
of $r$, the curve is interesting. It shows a rather good correlation at small
distances, but this correlation decreases rapidly. For larger values of $r$, we
do not observe $S_2(r)\to0$, which might reflect the fact that the specimen is
not isotropic (as shown in the <a href="#S1">previous section</a>); this should be
investigated further.</p>
<p><a name="Boundary_effects"></a></p>
<h2>Boundary effects</h2>
<p>To close this post on orientation correlations, we investigate boundary effects
in the specimen. The wall of the cylindrical sample container is
impenetrable. Therefore, the particles closest to the wall are tangent this
wall. We want to quantify the distance over which the grains keep the memory of
this preferred orientation.</p>
<p>To do so, for each grain, we locate the closest point on the wall, and the
corresponding normal vector. We first recall the location of the axis of the
container, and its radius (see <a href="https://sbrisard.github.io/posts/20150529-orientation_correlations_among_rice_grains-04.html">this
post</a>).</p>
<div class="highlight"><pre><span></span><span class="n">x_center</span> <span class="o">=</span> <span class="mi">219</span>
<span class="n">y_center</span> <span class="o">=</span> <span class="mi">217</span>
<span class="n">radius</span> <span class="o">=</span> <span class="mi">208</span>
</pre></div>


<p>We then compute the radius-vector (we discard the $z$-coordinate, which
is the first index), from which we deduce the normal to the boundary,
$\vec e_r$.</p>
<div class="highlight"><pre><span></span><span class="n">radius_vector</span> <span class="o">=</span> <span class="n">center</span><span class="o">-</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">]</span>
<span class="c1"># Discard first (z) coordinate!</span>
<span class="n">distance_to_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">radius_vector</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">distance_to_boundary</span> <span class="o">=</span> <span class="n">radius</span><span class="o">-</span><span class="n">distance_to_axis</span>
<span class="n">e_r</span> <span class="o">=</span> <span class="n">radius_vector</span><span class="o">/</span><span class="n">distance_to_axis</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>
<span class="n">e_r</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<p>We now compute the orthoradial vector $\vec e_\theta$,</p>
<div class="highlight"><pre><span></span><span class="n">e_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">e_r</span><span class="p">)</span>
<span class="n">e_theta</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">e_r</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">e_theta</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_r</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>


<p>For each grain, the direction $\vec n_i$ is decomposed in the local basis $(\vec
e_r, \vec e_\theta, \vec e_z)$.</p>
<div class="highlight"><pre><span></span><span class="n">orientation_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>
<span class="n">orientation_local</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_r</span><span class="o">*</span><span class="n">orientation</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">orientation_local</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_theta</span><span class="o">*</span><span class="n">orientation</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">orientation_local</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>


<p>We then compute the matrix representation of the tensor
$\vec n_i\otimes\vec n_i$ in the local basis.</p>
<div class="highlight"><pre><span></span><span class="n">nxn</span> <span class="o">=</span> <span class="n">orientation_local</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">orientation_local</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">distance_to_boundary</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="n">nxn_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nxn</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
</pre></div>


<p>The resulting statistical descriptors are plotted in <a href="#fig02">Fig. 2</a>. Honestly,
the results are not very conclusive. Both $\langle n_r\otimes n_r\rangle$ and
$\langle n_\theta\otimes n_\theta\rangle$ seem to decrease rapidly over a
distance of (roughly) 30 voxels. However, they both converge to a value which is
non-zero.</p>
<div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$r\;[\mathrm{vox}]$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle n_i\otimes n_i\rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nxn_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\langle n_r\otimes n_r\rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nxn_mean</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\langle n_\theta\otimes n_\theta\rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nxn_mean</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\langle n_z\otimes n_z\rangle$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;boundary_effects.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/usr/lib/python3/dist-packages/matplotlib/tight_layout.py:231: UserWarning: tight_layout : falling back to Agg renderer
  warnings.warn(&quot;tight_layout : falling back to Agg renderer&quot;)
</pre></div>


<p><a name="fig02"></a>
<img alt="Boundary effects" class="figure" src="https://sbrisard.github.io/posts/20160627-Orientation_correlations_among_rice_grains-08/boundary_effects.png"></p>
<figcaption>Figure&nbsp;2:&nbsp;Angular correlations with the orientation of the wall.</figcaption>

<h2>Conclusion</h2>
<p>This was the last post of this series on <em>Orientation correlations among rice
grains</em>. This post was dedicated to the <em>quantification</em> of orientation
correlations. To do so, we have recalled the definition of several statistical
descriptors. These descriptors were then evaluated on the sample.</p>
<p>The resulting values indeed indicate the existence of orientation
correlations. However, further investigations should be carried out in order to
draw reliable conclusions. In particular, the descriptors plotted in
Figs. <a href="#fig01">1</a> and <a href="#fig02">2</a> are histograms, and filtering of some sort
should be used to smooth the curves. Besides, the analysis of <a href="#S1">the first
section</a> shows that the sample is globally anisotropic. This global
anisotropy should be accounted for (“subtracted”) while analyzing local
anisotropy. In short, the present post should be considered as a mere
introduction to the matter and the relevant tools.</p>
<p>Well, I hope you enjoyed this series! We initially set out to quantify
orientation correlations in an assembly of rice grains. To do so, a fair amount
of image analysis was required. We introduced
<a href="https://sbrisard.github.io/posts/20150330-orientation_correlations_among_rice_grains-03.html">binning</a>,
the <a href="https://sbrisard.github.io/posts/20150529-orientation_correlations_among_rice_grains-04.html">Hough
transform</a>,
<a href="https://sbrisard.github.io/posts/20150709-orientation_correlations_among_rice_grains-05.html">Otsu's
method</a>, a
dedicated seeding technique for the <a href="https://sbrisard.github.io/posts/20150930-orientation_correlations_among_rice_grains-06.html">watershed
transform</a>
and the quantification of the
<a href="https://sbrisard.github.io/posts/20160219-orientation_correlations_among_rice_grains-07.html">morphology</a>
of the grains. All these techniques have a wide range of applications, which
goes far beyond the analysis of rice grains!</p>
  </div><!-- /.entry-content -->
</section>
<section>
  <h2>Comments</h2>
  <p>Please send your comments to <strong><code>sebastien [dot]
  brisard [at] univ [dash] eiffel [dot] fr</code></strong>. Your comments will be
  inserted below. Your email address will <em>not</em> appear.</p>
</section>
    <footer id="contentinfo" class="body">
      <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/" ><img alt="Creative Commons License" style="float:left;margin-right:5px;" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a>Except where otherwise noted, content on this blog by <a href="https://cv.archives-ouvertes.fr/sbrisard">Sébastien Brisard</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>&nbsp;&mdash;&nbsp;This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>&nbsp;&mdash;&nbsp;This blog uses <a href="https://www.nordtheme.com/">Nord</a>, an arctic north-bluish color palette.</p>
    </footer>
  </body>
</html>