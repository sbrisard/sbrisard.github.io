<!DOCTYPE html>
<html lang="en">
  <head>
      <title>Sébastien Brisard's blog - Orientation correlations among rice grains, part 7: analysis of the shape of the grains</title>
    <link rel="stylesheet" href="https://sbrisard.github.io/theme/css/main.css" />
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://sbrisard.github.io/theme/katex/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"/>
    <script defer src="https://sbrisard.github.io/theme/katex/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://sbrisard.github.io/theme/katex/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body, {macros: {'\\D': '\\mathrm{d}', '\\dbldot': '\\mathbin{\\mathord{:}}', '\\sym': '\\operatorname{\\mathbf{sym}}', '\\tgrad': '\\operatorname{\\mathbf{grad}}', '\\tens': '\\bm', '\\tr': '\\operatorname{tr}', '\\vec': '\\bm'}, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
    <link href="https://sbrisard.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="Sébastien Brisard's blog Full RSS Feed" />





  </head>

  <body id="index" class="home">
    <header id="siteheader">
      <img id="sitebanner" src="https://sbrisard.github.io/theme/images/banner.jpg"/>
      <div id="sitename"><a href="https://sbrisard.github.io/">Sébastien Brisard's blog <strong></strong></a></div>
      <nav id="sitemenu">
	<ul>
          <li><a href="/pages/about.html" title="About this blog">About this blog</a></li>
          <li><a href="https://cv.archives-ouvertes.fr/sbrisard" title="About me">About me</a></li>
          <li><a href="/archives.html" title="Archives">Archives</a></li>
          <li><a href="https://github.com/sbrisard" title="GitHub">GitHub</a></li>
          <li><a href="https://twitter.com/SebBrisard" title="Twitter">Twitter</a></li>
          <li><a href="feed.xml" title="RSS">RSS</a></li>
	</ul>
      </nav>
    </header>
<section id="content" class="body">
  <header>
    <h1 class="entry-title">
      <a href="https://sbrisard.github.io/posts/20160219-orientation_correlations_among_rice_grains-07.html" rel="bookmark"
         title="Permalink to Orientation correlations among rice grains, part 7: analysis of the shape of the grains">Orientation correlations among rice grains, part 7: analysis of the shape of the grains</a></h1>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2016-02-19T00:00:00+01:00">
      Published 19 February 2016
    </time>
    <address class="vcard author">
      by           <a class="url fn" href="https://sbrisard.github.io/author/sebastien-brisard.html">Sébastien Brisard</a>
    </address>
    <div class="category">
        Category: <a href="https://sbrisard.github.io/category/image-analysis.html">Image analysis</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>$\newcommand{\tens}{\mathbf}\newcommand{\D}{\mathrm{d}}$</p>
<p>In the <a href="https://sbrisard.github.io/posts/20150930-orientation_correlations_among_rice_grains-06.html">previous
instalment</a>
of this series, we have segmented the 3D image of the assembly of rice
grains. In other words, each voxel of the image is attributed the label of the
grain to which it belongs. Remember the <a href="https://sbrisard.github.io/posts/20150223-orientation_correlations_among_rice_grains-01.html">initial
goal</a> of
this series: we want to quantify orientation <em>correlations</em> between grains. To
do so, we must analyse the orientation of each individual grain. This is the
topic of the present post.</p>
<p>It is customary to define the orientation of an elongated object by means of the
eigenvectors of the tensor of second moments, defined as follows</p>
<p><a name="eq01"></a>
$$J_{ij} = \int_\text{Grain}\bigl(x_i-X_i\bigr)\bigl(x_j-X_j\bigr)\D x_1\,\D x_2\,\D x_3,\tag{1}$$</p>
<p>where the integral is carried out over the grain, and $X_i$ denotes the $i$-th
coordinate of the grain's center of mass</p>
<p>$$X_i = \frac1V\int_\text{Grain}x_i\,\D x_1\,\D x_2\,\D x_3$$</p>
<p>($V$: volume of the grain). In coordinate-free form, Eq. <a href="#eq01">(1)</a> reads</p>
<p>$$\tens J=\int_\text{Grain}\bigl(\vec x-\vec X\bigr)\otimes\bigl(\vec x-\vec X\bigr)\D x_1\,\D x_2\,\D x_3.$$</p>
<p>The above defined tensor of second moments is related to the <a href="https://en.wikipedia.org/wiki/Moment_of_inertia#The_inertia_tensor">inertia
tensor</a>
$\tens I$</p>
<p><a name="eq02"></a>
$$\tens I=\operatorname{tr}\tens J\,\tens\delta-\tens J,\tag{2}$$</p>
<p>where $\tens I$ is defined as follows</p>
<p>$$\tens I=\int_\text{Grain}\bigl[\bigl(\vec x-\vec X\bigr)\cdot\bigl(\vec x-\vec X\bigr)\tens\delta-\bigl(\vec x-\vec X\bigr)\otimes\bigl(\vec x-\vec X\bigr)\bigr]\D x_1\,\D x_2\,\D x_3.$$</p>
<p>Being symmetric, the tensor $\tens J$ of second moments is diagonalizable, and
we compute its eigenvalues $J_a$, $J_b$ and $J_c$, and the associated
eigenvectors $\vec v_a$, $\vec v_b$ and $\vec v_c$</p>
<p>$$\tens J\cdot\vec v_\alpha=J_\alpha\vec v_\alpha,$$</p>
<p>where $\alpha=a, b, c$. In the present post, we define the orientation of the
grain as the eigenvector associated to the <em>largest</em> eigenvalue.  We can further
define the equivalent ellipsoid as the ellipsoid with same volume and principal
second moments. It can readily be verified that the volume and principal second
moments of an ellipsoid are</p>
<p>$$V=\frac{4\pi}3 abc,\quad J_a=\frac{Va^2}5,\quad J_b=\frac{Vb^2}5,\quad J_c=\frac{Vc^2}5,$$</p>
<p>where $a$, $b$ and $c$ are the radii of the ellipsoid. The above expressions can
be retrieved from
<a href="https://en.wikipedia.org/wiki/Ellipsoid#Dynamical_properties">Wikipedia</a> and
Eq. <a href="#eq02">(2)</a>. For example</p>
<p>$$J_a = \frac12\bigl(I_b+I_c-I_a\bigr).$$</p>
<p>Then, the radii of the equivalent ellipsoid are retrieved as follows from the
volume $V$ and the principal second moments $J_a$, $J_b$ and $J_c$ of the
grain</p>
<p>$$a=\sqrt{\frac{5I_a}V},\quad b=\sqrt{\frac{5I_b}V},\quad c=\sqrt{\frac{5I_c}V}.$$</p>
<p>The radii of the equivalent ellipsoid can be used to characterize the size of
the grains. In the present post, we <a href="#morphological_description">compute for each
grain</a>: the volume, the center of mass, the tensor
of second moments, the orientation and the radii of the equivalent ellipsoid. We
will then perform rudimentary analysis of these morphological parameters.</p>
<p>As usual, we will use Python to carry out the dirty work. We will start with a
<a href="#direct_computation">very naive approach</a> and present a nearly <a href="#using_sum">loop-free
approach</a> using the clever <code>scipy.ndimage.sum</code> function. We start
with loading the segmented images.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span>

<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="kn">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.figure</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>

<span class="c1">#plt.style.use(&#39;../include/zenburn-light.mplstyle&#39;)</span>

<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;/media/sf_sbrisard/Documents/tmp/rice-bin_4x4x4.hdf5&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span>

<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="c1"># Discard index 0, which is the background</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</pre></div>


<p><a name="morphological_description"></a></p>
<h2>Morphological description of the grains</h2>
<p><a name="direct_computation"></a></p>
<h3>Direct computation of the morphological parameters of grain 42</h3>
<p>The direct (naive) approach presented in this section will serve as a reference
for a <a href="#using_sum">better approach</a> presented in the next section. It will be
illustrated on one grain only (namely grain
<a href="https://en.wikipedia.org/wiki/42_%2528number%2529#The_Hitchhiker.27s_Guide_to_the_Galaxy">42</a>),
which we first locate. The remainder of the analysis is then restricted to a ROI
surrounding the selected grain.</p>
<div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">slices</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">)[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">roi</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
</pre></div>


<p>The grain shape is then defined by <code>mask</code>, an array of booleans, where all
voxels of the ROI that belong to the grain are set to <code>True</code>.</p>
<div class="highlight"><pre><span></span><span class="n">mask</span> <span class="o">=</span> <span class="n">roi</span> <span class="o">==</span> <span class="n">index</span>
</pre></div>


<p>The volume (in voxels) of the grain is the sum of the above array</p>
<div class="highlight"><pre><span></span><span class="n">vol_ref</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Volume of grain {} = {} vox^3.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vol_ref</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre><span></span>Volume of grain 42 = 7087 vox^3.
</pre></div>


<p>To compute the center of mass and inertia of the grain, we must define the
coordinates of each voxel of the grain. To do so, we use the
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.mgrid.html">mgrid</a>
function</p>
<div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>


<p>The center of mass of the grain is the sum of these coordinates divided by the
total volume</p>
<div class="highlight"><pre><span></span><span class="n">com_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">vol_ref</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Center of mass of grain {} = {} vox&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">com_ref</span><span class="p">))</span>
</pre></div>


<div class="highlight"><pre><span></span>Center of mass of grain 42 = [  4.92069987 191.41597291 103.69183011] vox
</pre></div>


<p>Note that we pre-multiplied <code>coords</code> by <code>mask</code> in order to keep only those
voxels that belong to the grain. To compute the inertia of the grain, we first
subtract the coordinates of the center of mass from the voxel coordinates.</p>
<div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">-=</span> <span class="n">com_ref</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
</pre></div>


<p>We then compute the array of coordinates cross-products <code>coords_xprod</code> defined
as follows</p>
<div class="highlight"><pre><span></span><span class="n">coords_xprod</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">coords</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
</pre></div>


<p>(<code>i, j, k</code>: voxel indices; <code>m, n</code>: coordinates indices). The <code>coords_xprod</code>
array is produced by the following line of code</p>
<div class="highlight"><pre><span></span><span class="n">coords_xprod</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">coords</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>


<p>and we find</p>
<div class="highlight"><pre><span></span><span class="n">moments2_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="o">*</span><span class="n">coords_xprod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Moments of inertia of grain {} (vox^5)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">moments2_ref</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>Moments of inertia of grain 42 (vox^5)
[[ 71603.43332863 -45107.22322562 -71060.19147735]
 [-45107.22322562 426435.7118668  181708.48483138]
 [-71060.19147735 181708.48483138 880736.95696345]]
</pre></div>


<p>This is a bit tedious, isn't it? Besides, we should normally loop over the
grains in order to carry out the analysis for all grains. Comes the wonderful
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sum.html">scipy.ndimage.sum</a>
function to the rescue!</p>
<p><a name="using_sum"></a></p>
<h3>Using the <code>scipy.ndimage.sum</code> function</h3>
<p>This function will allow us to carry out the analysis over all grains
simultaneously. We start with the volume, which is seen as</p>
<p>$$V=\sum_\text{Grain} 1,$$</p>
<p>where the sum is carried over all voxels of each grain.</p>
<div class="highlight"><pre><span></span><span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">vol</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>


<p>And we can check that the value we found for grain 42 is correct</p>
<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Volume of grain {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    expected   = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol_ref</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    actual     = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>


<div class="highlight"><pre><span></span>Volume of grain 42
    expected   = 7087
    actual     = 7087.0
</pre></div>


<p>For the center of mass, we will use the
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html">center_of_mass</a>
function rather than the
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sum.html">sum</a>
function.</p>
<div class="highlight"><pre><span></span><span class="n">com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Center of mass of grain {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    expected   = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">com_ref</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    actual     = {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>


<div class="highlight"><pre><span></span>Center of mass of grain 42
    expected   = [  4.92069987 191.41597291 103.69183011]
    actual     = [  4.92069987 191.41597291 103.69183011]
</pre></div>


<p>Finally, the second moments are seen as the following sum</p>
<p>$$J_{ij}=\sum_\text{Grain}(x_i-X_i)(x_j-X_j)=\sum_\text{Grain}x_ix_j-VX_iX_j,$$</p>
<p>where the last identity is known as the <a href="https://en.wikipedia.org/wiki/Parallel_axis_theorem">parallel axis
theorem</a>. Implementation
of this formulation is straightforward, starting from the construction of the
array of voxel coordinates <code>coords</code>.</p>
<div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[[</span><span class="nb">slice</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">]]</span>
<span class="n">moments2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">xj</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">moments2</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xj</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-</span>
                             <span class="n">vol</span><span class="o">*</span><span class="n">com</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">com</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
</pre></div>


<p><strong>Nota:</strong> I could not find a pythonic way to get rid of this uggly nested loop…</p>
<p>We can again check that the result is correct for grain 42.</p>
<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;Second moments of grain {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    expected =&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">moments2_ref</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;    actual =&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">moments2</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>


<div class="highlight"><pre><span></span>Second moments of grain 42
    expected =
[[ 71603.43332863 -45107.22322562 -71060.19147735]
 [-45107.22322562 426435.7118668  181708.48483138]
 [-71060.19147735 181708.48483138 880736.95696345]]
    actual =
[[ 71603.43332863 -45107.22322562 -71060.19147735]
 [-45107.22322562 426435.7118668  181708.48483139]
 [-71060.19147735 181708.48483139 880736.95696346]]
</pre></div>


<p>That's it! We have computed the second moments of each grain. See how this <code>sum</code>
function is convenient? We are now ready to compute the orientation of each
grain, as well as the radii of the equivalent ellipsoid. We first compute the
eigenvalues and eigenvectors of the tensors of second moments.</p>
<div class="highlight"><pre><span></span><span class="n">moments2_eigvals</span><span class="p">,</span> <span class="n">moments2_eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">moments2</span><span class="p">)</span>
</pre></div>


<p>The <em>orientation</em> $\vec n$ of the grain is defined as the eigenvector associated
with the largest principal second moment.</p>
<div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">moments2_eigvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">moments2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">moments2_eigvecs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>[[ 0.01955891  0.05286465 -0.99841012]
 [-0.17300079 -0.67355818 -0.71860288]
 [-0.49498664 -0.84077194  0.21929608]
 ...
 [-0.14766036  0.2963219  -0.94360466]
 [ 0.          1.          0.        ]
 [-0.1722074   0.98321974  0.06019601]]
</pre></div>


<p>The following code snippet computes the radii of each grain, and sorts them in
ascending order.</p>
<div class="highlight"><pre><span></span><span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">moments2_eigvals</span><span class="o">/</span><span class="n">vol</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]))</span>
</pre></div>


<p>We can now proceed with the analysis of the results. This will be done more
thoroughly in the next instalment of this series. The present post will be
restricted to basic analyses. But first of all, it is time to save our results!
with h5py.File(filename, 'r+') as f:
    f['volume'] = vol
    f['center_of_mass'] = com
    f['radii'] = radius
    f['orientation'] = n</p>
<h2>Analysis of the results</h2>
<h3>Volume of grains</h3>
<div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;V (vox³)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Number&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12000</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;./volume_histogram.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/usr/lib/python3/dist-packages/matplotlib/tight_layout.py:231: UserWarning: tight_layout : falling back to Agg renderer
  warnings.warn(&quot;tight_layout : falling back to Agg renderer&quot;)
</pre></div>


<p><img alt="Volume" class="figure" src="https://sbrisard.github.io/posts/20160219-Orientation_correlations_among_rice_grains-07/volume_histogram.png">
Most grains have a volume comprised between 6000 and 8000 vox³. It is observed
that a significant number of grains are very small. There are two possible
explanations for this</p>
<ol>
<li>some grains where broken in smaller pieces,</li>
<li>our
   <a href="20150930-Orientation_correlations_among_rice_grains-06.org">segmentation</a>
   was not perfect (over-segmentation might have occured).</li>
</ol>
<p>My guess is that it is in fact a little bit of both. One possible remedy would
be to filter out those grains that are too small in the subsequent analysis. We
will not go into such degree of refinment.</p>
<h3>Size of the grains</h3>
<p>In this section we visualize the radii of the equivalent ellipsoids</p>
<div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">radius</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;a (vox)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Number&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;radius_a_histogram.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">((</span><span class="n">radius</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">radius</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;b, c (vox)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Number&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;radii_b_c_histogram.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/usr/lib/python3/dist-packages/matplotlib/tight_layout.py:231: UserWarning: tight_layout : falling back to Agg renderer
  warnings.warn(&quot;tight_layout : falling back to Agg renderer&quot;)
</pre></div>


<p><img alt="Radius a" src="https://sbrisard.github.io/posts/20160219-Orientation_correlations_among_rice_grains-07/radius_a_histogram.png"><img alt="Radius b, c" src="https://sbrisard.github.io/posts/20160219-Orientation_correlations_among_rice_grains-07/radii_b_c_histogram.png">
The length of most grains is about 2×27=54 pixels (about 6.5 mm). Also, the
grains are <em>not</em> spheroids: indeed $b\neq c$.</p>
<h3>Orientation of grains</h3>
<p>This will be the topic of the next instalment of this series. We will only check
for possible anisotropy by analysing the following second-order orientation
tensor: $\langle\vec n\otimes\vec n\rangle$, where angle brackets stand for
ensemble average. It can readily be verified that for isotropic distributions,
this tensor is diagonal</p>
<p>$$\langle\vec n\otimes\vec n\rangle=
\frac 13
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}.$$</p>
<p>Any deviation from this diagonal tensor indicates anisotropy (the converse is
<em>not</em> true!). Computation of this orientation tensor is easy</p>
<div class="highlight"><pre><span></span><span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">n</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">None</span><span class="p">]</span>
<span class="n">nn_avg</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">nn_avg</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>[[ 0.27082401  0.02535001 -0.02444013]
 [ 0.02535001  0.34864242 -0.00637534]
 [-0.02444013 -0.00637534  0.38053357]]
</pre></div>


<p>Which shows that the distribution of grains is <em>not</em> isotropic. Analysis
of the eigenvalues of the orientation tensor would show that the
vertical direction is in fact a direction of anisotropy (which should
not come as a surprise)… but we will leave it like that for now!</p>
<h2>Conclusion</h2>
<p>In this post, we have analysed the orientation of each grain. The orientation
was defined as the orientation of the major axis of the equivalent ellipsoid. We
are now ready to analyse orientation correlations among rice grains, which will
be the topic of the <a href="https://sbrisard.github.io/posts/20160627-orientation_correlations_among_rice_grains-08.html">next
instalment</a>.</p>
  </div><!-- /.entry-content -->
</section>
<section>
  <h2>Comments</h2>
  <p>Please send your comments to <strong><code>sebastien [dot]
  brisard [at] univ [dash] eiffel [dot] fr</code></strong>. Your comments will be
  inserted below. Your email address will <em>not</em> appear.</p>
</section>
    <footer id="contentinfo" class="body">
      <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/" ><img alt="Creative Commons License" style="float:left;margin-right:5px;" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a>Except where otherwise noted, content on this blog by <a href="https://cv.archives-ouvertes.fr/sbrisard">Sébastien Brisard</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>&nbsp;&mdash;&nbsp;This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>&nbsp;&mdash;&nbsp;This blog uses <a href="https://www.nordtheme.com/">Nord</a>, an arctic north-bluish color palette.</p>
    </footer>
  </body>
</html>