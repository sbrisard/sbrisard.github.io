<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2018-03-19">

<title>SÃ©bastien Brisardâ€™s blog - On the periodic-plus-smooth decomposition of an image, part 6: minimizing the energy, the clever way</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">SÃ©bastien Brisardâ€™s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://cv.archives-ouvertes.fr/sbrisard"> 
<span class="menu-text">About the author</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/sbrisard"> 
<span class="menu-text">GitHub</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">On the periodic-plus-smooth decomposition of an image, part 6: minimizing the energy, the clever way</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 19, 2018</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In the <a href="../20180312-On_the_periodic-plus-smooth_decomposition_of_an_image-05">previous instalment</a> of this series, we computed Moisanâ€™s (<a href="https://doi.org/10.1007/s10851-010-0227-1">2011</a>) periodic-plus-smooth decomposition of an image by means of the <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient method</a>. This worked like a charm, but was fairly inefficient, owing to the iterative nature of the method. Moisan actually showed that the whole decomposition could be computed explicitly in Fourier space. This will be discussed in the present post, which is the sixth in a series in seven parts:</p>
<ol type="1">
<li><a href="../20180212-On_the_periodic-plus-smooth_decomposition_of_an_image-01">Introduction</a></li>
<li><a href="../20180219-On_the_periodic-plus-smooth_decomposition_of_an_image-02">Defining the decomposition</a></li>
<li><a href="../20180226-On_the_periodic-plus-smooth_decomposition_of_an_image-03">The energy as a quadratic form</a></li>
<li><a href="../20180305-On_the_periodic-plus-smooth_decomposition_of_an_image-04">Implementing the linear operators</a></li>
<li><a href="../20180312-On_the_periodic-plus-smooth_decomposition_of_an_image-05">Minimizing the energy, the clumsy way</a></li>
<li><a href="../20180319-On_the_periodic-plus-smooth_decomposition_of_an_image-06">Minimizing the energy, the clever way</a></li>
<li><a href="../20180326-On_the_periodic-plus-smooth_decomposition_of_an_image-07">Improved implementation of Moisanâ€™s algorithm</a></li>
</ol>
<p>The code discussed in this series is available as a Python module on <a href="https://github.com/sbrisard/moisan2011">GitHub</a>.</p>
<p>Before we proceed, let us recall how the <a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform">discrete Fourier transform</a> <span class="math inline">\(\hat{u}\)</span> of the <span class="math inline">\(m\times n\)</span> image <span class="math inline">\(u\)</span> is defined as follows <span class="math display">\[
\hat{u}_{\alpha\beta}=\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}u_{ij}\exp\Bigl[-2\pi\mathrm i\Bigl(\frac{\alpha i}m+\frac{\beta j}n\Bigr)\Bigr],
\]</span> for <span class="math inline">\(\alpha=0, \ldots, m-1\)</span> and <span class="math inline">\(\beta=0, \ldots, n-1\)</span>. We have the well-known inversion formula <span class="math display">\[
u_{ij}=\frac1{mn}\sum_{\alpha=0}^{m-1}\sum_{\beta=0}^{n-1}\hat{u}_{\alpha\beta}\exp\Bigl[2\pi\mathrm i\Bigl(\frac{\alpha i}m+\frac{\beta j}n\Bigr)\Bigr].
\]</span></p>
<p>The remainder of this post is organized as follows. We will first introduce <a href="#algorithm">Moisanâ€™s algorithm</a> (<a href="https://doi.org/10.1007/s10851-010-0227-1">2011</a>). Then a first implementation of this algorithm will be proposed and tested. Improved implementations will be discussed in the <a href="../20180326-On_the_periodic-plus-smooth_decomposition_of_an_image-07">next instalment</a> of this series.</p>
<section id="moisans-algorithm" class="level1">
<h1>Moisanâ€™s algorithm</h1>
<p>It is recalled (see <a href="../20180312-On_the_periodic-plus-smooth_decomposition_of_an_image-05">previous post</a>) that the smooth component <span class="math inline">\(s\)</span> of a <span class="math inline">\(m\times n\)</span> image <span class="math inline">\(u\)</span> is found from the solution to the following linear system <span id="eq-01"><span class="math display">\[
Q\cdot s=Q_1\cdot u,
\tag{1}\]</span></span> where <span class="math inline">\(Q\)</span> and <span class="math inline">\(Q_1\)</span> are symmetric, positive linear operators defined in <em>part 3</em> of this series (<span class="math inline">\(Q\)</span> is actually positive definite). As observed in <a href="../20180305-On_the_periodic-plus-smooth_decomposition_of_an_image-04.md">part 4</a> of this series, operator <span class="math inline">\(Q\)</span> is in fact the sum of the periodic convolution operator with the following kernel <span class="math display">\[
\begin{bmatrix}
0 &amp; -2 &amp; 0\\
-2 &amp; 8 &amp; -2\\
0 &amp; -2 &amp; 0
\end{bmatrix}
\]</span> and the operator that maps any image <span class="math inline">\(u\)</span> onto the constant image equal to <span class="math inline">\(\operatorname{mean}u/mn\)</span>. It then results from the <a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem">circular convolution theorem</a> that <span id="eq-02"><span class="math display">\[
(\widehat{Q\cdot s})_{\alpha\beta}
=\begin{cases}
m^{-2}n^{-2}\hat{s}_{00} &amp; \text{if }(\alpha, \beta) = (0, 0),\\
\bigl(8-4\cos\frac{2\pi\alpha}m-4\cos\frac{2\pi\beta}n\bigr)\hat{s}_{\alpha\beta} &amp; \text{otherwise}.
\end{cases}
\tag{2}\]</span></span></p>
<p>Combining Eqs.&nbsp;(<a href="#eq-01" class="quarto-xref">1</a>) and (<a href="#eq-02" class="quarto-xref">2</a>), we find the following expression of the discrete Fourier transform of the smooth component <span class="math inline">\(s\)</span> <span id="eq-03"><span class="math display">\[
\hat{s}_{\alpha\beta}=\frac{\hat{v}_{\alpha\beta}}{2\cos\frac{2\pi\alpha}m+2\cos\frac{2\pi\beta}n-4}\quad\text{for}\quad(\alpha, \beta)\neq(0, 0),
\tag{3}\]</span></span> where we have introduced <span class="math inline">\(v=-\frac12Q_1\cdot u\)</span>. Since <span class="math inline">\(\operatorname{mean}s=0\)</span>, we also have <span class="math inline">\(\hat{s}_{00}=0\)</span>. From the definition of <span class="math inline">\(Q_1\)</span> (see <a href="../20180226-On_the_periodic-plus-smooth_decomposition_of_an_image-03.md#Q1">part 3</a> of this series), we have <span class="math inline">\(v=v^\mathrm h+v^\mathrm v\)</span>, with <span id="eq-04"><span class="math display">\[
v^\mathrm h_{ij}=
\begin{cases}
u_{i, n-1}-u_{i, 0} &amp; \text{if }j=0,\\
u_{i, 0}-u_{i, n-1} &amp; \text{if }j=n-1,\\
0                   &amp; \text{otherwise},
\end{cases}
\tag{4}\]</span></span> and <span id="eq-05"><span class="math display">\[v^\mathrm v_{ij}=
\begin{cases}
u_{m-1, j}-u_{0, j} &amp; \text{if }i=0,\\
u_{0, j}-u_{m-1, j} &amp; \text{if }i=m-1,\\
0                   &amp; \text{otherwise}.
\end{cases}
\tag{5}\]</span></span></p>
<p>Moisanâ€™s algorithm (<a href="https://doi.org/10.1007/s10851-010-0227-1">2011</a>) readily follows from this analysis</p>
<ol type="1">
<li>compute <span class="math inline">\(v\)</span> â€“ use Eqs.&nbsp;(<a href="#eq-04" class="quarto-xref">4</a>) and (<a href="#eq-05" class="quarto-xref">5</a>),</li>
<li>compute its discrete Fourier transform <span class="math inline">\(\hat{v}\)</span>,</li>
<li>compute <span class="math inline">\(\hat{s}\)</span> â€“ use Eq.&nbsp;(<a href="#eq-03" class="quarto-xref">3</a>),</li>
<li>compute its inverse discrete Fourier transform <span class="math inline">\(s\)</span>,</li>
<li>compute <span class="math inline">\(p=u-s\)</span>.</li>
</ol>
<p>Of course, the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">fast Fourier transform</a> will be used for steps 2 and 4.</p>
</section>
<section id="a-first-implementation-of-moisans-algorithm" class="level1">
<h1>A first implementation of Moisanâ€™s algorithm</h1>
<p>Reference implementation of Moisanâ€™s algorithm results directly from the above analysis.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _per(u, inverse_dft<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute the periodic component of the 2D image u.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This function returns the periodic-plus-smooth decomposition of</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    the 2D array-like u.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    If inverse_dft is True, then the pair (p, s) is returned</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    (p: periodic component; s: smooth component).</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">    If inverse_dft is False, then the pair</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">        (numpy.fft.fft2(p), numpy.fft.fft2(s))</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    is returned.</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">    This is a reference (unoptimized) implementation of Algorithm 1.</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.asarray(u, dtype<span class="op">=</span>np.float64)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> np.zeros_like(u)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    du <span class="op">=</span> u[<span class="op">-</span><span class="dv">1</span>, :]<span class="op">-</span>u[<span class="dv">0</span>, :]</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    v[<span class="dv">0</span>, :] <span class="op">=</span> du</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    v[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">=</span> <span class="op">-</span>du</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    du <span class="op">=</span> u[:, <span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>u[:, <span class="dv">0</span>]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    v[:, <span class="dv">0</span>] <span class="op">+=</span> du</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    v[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-=</span> du</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    v_dft <span class="op">=</span> np.fft.fft2(v)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> u.shape</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    cos_m <span class="op">=</span> np.cos(<span class="fl">2.</span><span class="op">*</span>np.pi<span class="op">*</span>np.fft.fftfreq(m, <span class="fl">1.</span>))</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    cos_n <span class="op">=</span> np.cos(<span class="fl">2.</span><span class="op">*</span>np.pi<span class="op">*</span>np.fft.fftfreq(n, <span class="fl">1.</span>))</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    k_dft <span class="op">=</span> <span class="fl">2.0</span><span class="op">*</span>(cos_m[:, <span class="va">None</span>]<span class="op">+</span>cos_n[<span class="va">None</span>, :]<span class="op">-</span><span class="fl">2.0</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    k_dft[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    s_dft <span class="op">=</span> v_dft<span class="op">/</span>k_dft</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    s_dft[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> inverse_dft:</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> np.fft.ifft2(s_dft)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u<span class="op">-</span>s, s</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        u_dft <span class="op">=</span> np.fft.fft2(u)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u_dft<span class="op">-</span>s_dft, s_dft</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Which can be applied to the following image.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.io <span class="im">import</span> imread, imsave</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> imread(DATA_DIR<span class="op">+</span><span class="st">'hut-648x364.png'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> u.astype(np.float64)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="../On_the_periodic-plus-smooth_decomposition_of_an_image-files/hut-648x364.png" class="img-fluid"></p>
<p>The periodic-plus-smooth decomposition is then computed as follows.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>p, s <span class="op">=</span> _per(u, inverse_dft<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>imsave(DATA_DIR<span class="op">+</span><span class="st">'hut-648x364-periodic-_per-fftshift.png'</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>       np.fft.fftshift(p.real).astype(np.uint8))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Which results in the following image (<span class="math inline">\(p\)</span> has been FFT-shifted, in order to demonstrate the effect of periodization).</p>
<p><img src="../On_the_periodic-plus-smooth_decomposition_of_an_image-files/hut-648x364-periodic-_per-fftshift.png" class="img-fluid"></p>
<p>It should be noted that the resulting decomposition is a pair of <em>complex</em> images (since we used the complex DFT to perform the decomposition). We ought to check that the imaginary parts of <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> are indeed nearly null</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Imaginary part of'</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'  p: min = </span><span class="sc">{}</span><span class="st">, max = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(p.imag.<span class="bu">min</span>(), p.imag.<span class="bu">max</span>()))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'  s: min = </span><span class="sc">{}</span><span class="st">, max = </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(s.imag.<span class="bu">min</span>(), s.imag.<span class="bu">max</span>()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Imaginary part of
  p: min = -2.6931883320843306e-12, max = 4.161745834921434e-12
  s: min = -4.161745834921434e-12, max = 2.6931883320843306e-12</code></pre>
<p>We can then readily set <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> to their real parts</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>p_act <span class="op">=</span> p.real</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>s_act <span class="op">=</span> s.real</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="testing-our-implementation" class="level1">
<h1>Testing our implementation</h1>
<p>In the <a href="../20180312-On_the_periodic-plus-smooth_decomposition_of_an_image-05">previous instalment</a> of this series, we computed a reference periodic-plus-smooth decomposition by means of the conjugate gradient method. Letâ€™s do that again.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse.linalg <span class="im">import</span> cg</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1E-8</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>Q1 <span class="op">=</span> OperatorQ1(u.shape)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> OperatorQ(u.shape)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> u.shape</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> Q1<span class="op">@</span>u.reshape((m<span class="op">*</span>n,))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>x_exp, info <span class="op">=</span> cg(Q, b, tol<span class="op">=</span>tol)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> info <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    res_exp <span class="op">=</span> np.linalg.norm(b<span class="op">-</span>Q<span class="op">@</span>x_exp)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Residual: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(res_exp))</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(info)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>s_exp <span class="op">=</span> x_exp.reshape(u.shape)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>p_exp <span class="op">=</span> u<span class="op">-</span>s_exp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Residual: 3.9422689362828e-05</code></pre>
<p>We can then compute the norm of the difference</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>abs_err <span class="op">=</span> np.linalg.norm(s_act<span class="op">-</span>s_exp)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>rel_err <span class="op">=</span> abs_err<span class="op">/</span>np.linalg.norm(<span class="fl">0.5</span><span class="op">*</span>(s_act<span class="op">+</span>s_exp))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Error in L2-norm:'</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'  - absolute: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(abs_err))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'  - relative: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(rel_err))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Error in L2-norm:
  - absolute: 0.004504952971826568
  - relative: 1.3139651711483983e-06</code></pre>
<p>This is already quite satisfactory. We can also compute the residual with the value of <span class="math inline">\(s\)</span> found through the DFT approach</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>x_act <span class="op">=</span> s_act.reshape((m<span class="op">*</span>n,))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>res_act <span class="op">=</span> np.linalg.norm(b<span class="op">-</span>Q<span class="op">@</span>x_act)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Residual: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(res_act))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Residual: 1.8964547594731774e-11</code></pre>
<p>Which is much smaller than the residual obtained through conjugate gradient iterations! Surely, our implementation delivers the correct periodic-plus-smooth decomposition!</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In the present post, we have implemented Moisansâ€™s algorithm (<a href="https://doi.org/10.1007/s10851-010-0227-1">2011</a>) for computing the periodic-plus-smooth decomposition of an image. This algorithm is much faster than our <a href="../20180312-On_the_periodic-plus-smooth_decomposition_of_an_image-05">previous</a> implementation, relying on the conjugate gradient method. We will show in the <a href="../20180326-On_the_periodic-plus-smooth_decomposition_of_an_image-07">next instalment</a> of this series that we can do slightly better, though.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Except where otherwise noted, content on this blog by SÃ©bastien Brisard is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></p>
</div>
    <div class="nav-footer-right">
<p>ðŸ“§â€‹ sebastien [dot] brisard [at] univ [dash] amu [dot] fr</p>
</div>
  </div>
</footer>




</body></html>